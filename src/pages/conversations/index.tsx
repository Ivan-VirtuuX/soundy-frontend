import React from "react";

import { GetServerSideProps, NextPage } from "next";
import Head from "next/head";

import { MainLayout } from "@/layouts/MainLayout";

import { PageTitle } from "@/components/ui/PageTitle";
import { SearchInput } from "@/components/SearchInput";
import { ConversationItem } from "@/components/ConversationItem";
import { Line } from "@/components/ui/Line";
import { NullResultsBlock } from "@/components/ui/NullResultsBlock";

import { IConversation } from "@/api/types";
import { Api } from "@/api/index";

import { socket } from "@/utils/SocketContext";

import { useAutoAnimate } from "@formkit/auto-animate/react";

import { useAppSelector } from "@/redux/hooks";
import { selectUserData } from "@/redux/slices/user";

import styles from "./Conversations.module.scss";

interface ConversationsProps {
  conversations: IConversation[];
}

const Conversations: NextPage<ConversationsProps> = ({ conversations }) => {
  const [localConversations, setLocalConversations] =
    React.useState<IConversation[]>(conversations);
  const [searchText, setSearchText] = React.useState("");

  const [parent] = useAutoAnimate();

  const userData = useAppSelector(selectUserData);

  const onDeleteConversation = async (conversationId: string) => {
    try {
      await Api().conversation.deleteConversation(conversationId);

      setLocalConversations([
        ...localConversations.filter(
          (conversation) => conversation.conversationId !== conversationId
        ),
      ]);
    } catch (err) {
      console.warn(err);
    }
  };

  const filterConversations = (searchText: string): IConversation[] => {
    return localConversations.filter((conversation) => {
      const conversationUser =
        conversation.receiver?.userId === userData?.id
          ? conversation.sender
          : conversation.receiver;

      return (
        conversationUser.name
          .toLowerCase()
          .includes(searchText.toLowerCase()) ||
        conversationUser.surname
          .toLowerCase()
          .includes(searchText.toLowerCase()) ||
        conversationUser.login
          .toLowerCase()
          .includes(searchText.toLowerCase()) ||
        (conversationUser.name
          .toLowerCase()
          .includes(searchText.split("")[0]?.toLowerCase()) &&
          conversationUser.surname
            .toLowerCase()
            .includes(searchText.split("")[1]?.toLowerCase())) ||
        conversation.messages.some((msg) =>
          msg.content.text.toLowerCase().includes(searchText.toLowerCase())
        )
      );
    });
  };

  React.useEffect(() => {
    (async () => {
      try {
        socket.on("onMessage", async (payload) => {
          const data = await Api().conversation.getAll();

          setLocalConversations(data);
        });
      } catch (err) {
        console.warn(err);
      }
    })();

    return () => {
      socket.off("onMessage");
      socket.off("onDeleteMessage");
      socket.off("message");
    };
  }, [socket]);

  return (
    <MainLayout fullWidth>
      <Head>
        <title>Сообщения</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicons/favicon.ico" />
      </Head>
      <main className={styles.container}>
        <PageTitle pageTitle="Сообщения" />
        {localConversations.length !== 0 && (
          <SearchInput
            handleChange={(text) => setSearchText(text)}
            width={600}
          />
        )}
        {localConversations.length !== 0 ? (
          <ul className={styles.conversationsBlock} ref={parent}>
            {searchText
              ? filterConversations(searchText)?.map((obj) => (
                  <li key={obj.conversationId}>
                    <ConversationItem
                      {...obj}
                      handleDeleteConversation={onDeleteConversation}
                    />
                    {obj.conversationId !==
                      localConversations[localConversations.length - 1]
                        ?.conversationId && <Line />}
                  </li>
                ))
              : localConversations?.map((obj) => (
                  <li key={obj.conversationId}>
                    <ConversationItem
                      {...obj}
                      handleDeleteConversation={onDeleteConversation}
                    />
                    {obj.conversationId !==
                      localConversations[localConversations.length - 1]
                        ?.conversationId && <Line />}
                  </li>
                ))}
          </ul>
        ) : (
          <NullResultsBlock text="Список диалогов пуст" />
        )}
      </main>
    </MainLayout>
  );
};

export default Conversations;

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  if (!ctx.req.cookies.authToken) {
    return {
      redirect: {
        destination: "/",
        permanent: false,
      },
    };
  }
  const data = await Api(ctx).conversation.getAll();

  return {
    props: { conversations: data },
  };
};

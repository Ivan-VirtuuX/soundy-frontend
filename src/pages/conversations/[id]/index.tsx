import React, { useContext } from "react";

import { GetServerSideProps, NextPage } from "next";
import { v4 as uuidv4 } from "uuid";
import Head from "next/head";

import { MainLayout } from "@/layouts/MainLayout";

import { MessageItem } from "@/components/MessageItem";
import { EmptyAvatar } from "@/components/ui/EmptyAvatar";
import { CrossIcon } from "@/components/ui/Icons/CrossIcon";

import { IconButton } from "@mui/material";

import styles from "./Conversation.module.scss";
import { AttachImagePopup } from "@/components/AttachImagePopup";
import { SendIcon } from "@/components/ui/Icons/SendIcon";
import { SocketContext } from "@/utils/SocketContext";
import { useAppSelector } from "@/redux/hooks";
import { selectUserData } from "@/redux/slices/user";
import { useRouter } from "next/router";
import { Api } from "@/api/index";
import { IMessage } from "@/api/types";

interface ConversationProps {
  messages: IMessage[];
}

const Conversation: NextPage<ConversationProps> = ({ messages }) => {
  const [message, setMessage] = React.useState("");
  const [imageFormData, setImageFormData] = React.useState([]);
  const [attachedImageFormData, setAttachedImageFormData] = React.useState([]);
  const [image, setImage] = React.useState<File>();
  const [attachedImage, setAttachedImage] = React.useState<File>();
  const [isSave, setIsSave] = React.useState(false);
  const [isSaveImage, setIsSaveImage] = React.useState(false);
  const [preview, setPreview] = React.useState("");
  const [isUploading, setIsUploading] = React.useState(false);
  const [localMessages, setLocalMessages] =
    React.useState<IMessage[]>(messages);
  const [isLoading, setIsLoading] = React.useState(true);

  const messageContainerRef = React.useRef(null);
  const contentRef = React.useRef(null);

  const moveUp = [
    {
      transform: "translateY(30px)",
      transition: "all 0.05s ease-in-out",
    },
    {
      transform: "translateY(0px)",
      transition: "all 0.05s ease-in-out",
    },
  ];

  const timing = {
    duration: 60,
    iterations: 1,
  };

  // React.useEffect(() => {
  //   (async () => {
  //     try {
  //       if (conversationId) {
  //         const data = await Api().message.getAll();
  //
  //         setMessages(
  //           data.filter((message) => message.conversationId === conversationId)
  //         );
  //
  //         setLocalMessages(
  //           data.filter((message) => message.conversationId === conversationId)
  //         );
  //       } else if (!conversationId) {
  //         const data = await Api().message.getAll();
  //
  //         setMessages(data);
  //       }
  //     } catch (err) {
  //       console.warn(err);
  //     } finally {
  //       setIsLoading(false);
  //     }
  //   })();
  // }, [conversationId, isSave]);

  const userData = useAppSelector(selectUserData);

  const socket = useContext(SocketContext);

  const router = useRouter();

  const { id } = router.query;

  const handleChangeAttachedImage = () => {};

  const handleSubmitNewMessage = async (
    e: React.FormEvent<HTMLFormElement>
  ) => {
    e.preventDefault();

    try {
      if (message) {
        setIsUploading(true);

        await Api().message.sendMessage({
          messageId: uuidv4(),
          conversationId: String(id),
          sender: { ...userData },
          text: message,
          createdAt: new Date(),
        });

        setMessage("");
      }
    } catch (err) {
      console.warn(err);
    } finally {
      setIsUploading(false);
    }
  };

  React.useEffect(() => {
    (async () => {
      try {
        socket.on("onMessage", async (payload) => {
          const { ...message } = payload;

          const data = await Api().conversation.getOne(message.conversationId);

          if (
            data.receiver?.userId === userData.id ||
            data.sender?.userId === userData.id
          ) {
            setLocalMessages((localMessages) => [...localMessages, message]);
          }
        });

        socket.on("onDeleteMessage", (messageId) => {
          setLocalMessages((localMessages) => [
            ...localMessages.filter(
              (message) => message.messageId !== messageId
            ),
          ]);
        });
      } catch (err) {
        console.warn(err);
      }
    })();

    return () => {
      socket.off("onMessage");
      socket.off("onDeleteMessage");
      socket.off("message");
    };
  }, [socket]);

  React.useEffect(() => {
    contentRef?.current?.animate(moveUp, timing);
  }, [localMessages]);

  return (
    <MainLayout fullWidth>
      <Head>
        <title>name surname</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicons/favicon.ico" />
      </Head>
      <main className={styles.container}>
        <div className={styles.head}>
          <div className={styles.leftSide}>
            <EmptyAvatar className={styles.avatar} />
            {/*<Image src={} alt="avatar"/>*/}
            <div className={styles.userInfo}>
              <div className={styles.nameSurname}>
                <span>Name</span>
                <span>Surname</span>
              </div>
              <span className={styles.nickname}>nickname</span>
            </div>
          </div>
          <IconButton
            className={styles.closeButton}
            onClick={() => router.push("/conversations")}
          >
            <CrossIcon size={16} color="#A9A9A9" />
          </IconButton>
        </div>
        <div className={styles.content} ref={contentRef}>
          {localMessages
            .map((message) => (
              <MessageItem
                key={message.messageId}
                {...message}
                innerRef={messageContainerRef}
              />
            ))
            .reverse()}
        </div>
        <div className={styles.bottom}>
          <form
            className={styles.messageInputFieldBlock}
            onSubmit={handleSubmitNewMessage}
          >
            <div className={styles.messageInputField}>
              <div className={styles.messageInputFieldContainer}>
                <input
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                    setMessage(e.target.value)
                  }
                  value={message}
                  type="text"
                  placeholder="Cообщение"
                />
                <AttachImagePopup
                  className={styles.attachImageButton}
                  handleChangeAttachedImage={handleChangeAttachedImage}
                />
              </div>
            </div>
            <IconButton
              type="submit"
              size="large"
              className={styles.sendMessageButton}
            >
              <SendIcon />
            </IconButton>
          </form>
        </div>
      </main>
    </MainLayout>
  );
};

export default Conversation;

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  if (!ctx.req.cookies.authToken) {
    return {
      redirect: {
        destination: "/",
        permanent: false,
      },
    };
  }
  const data = await Api().message.getAll();

  return {
    props: { messages: data },
  };
};
